# 垃圾回收：垃圾数据如何自动回收

> **📌 2025 更新说明**：本文最初撰写时基于 V8 早期的垃圾回收架构。自那以后，V8 团队通过 **Orinoco 项目** 对垃圾回收器进行了大规模的现代化改造，引入了并发标记（Concurrent Marking）、并行清道夫（Parallel Scavenging）、并发清除（Concurrent Sweeping）等关键优化，极大地降低了 GC 停顿对主线程的影响。本次更新在保留原有核心概念的基础上，补充了这些现代 GC 技术的细节、性能监控手段，以及主流 JavaScript 引擎之间的 GC 策略对比，以帮助读者建立更完整、更贴近当前工程实践的认知。

有些数据被使用之后，可能就不再需要了，我们把这种数据称为垃圾数据。如果这些垃圾数据一直保存在内存中，那么内存会越用越多，所以我们需要对这些垃圾数据进行回收，以释放有限的内存空间。

## 不同语言的垃圾回收策略

通常情况下，垃圾数据回收分为手动回收和自动回收两种策略。

如 C/C++ 就是使用手动回收策略，何时分配内存、何时销毁内存都是由代码控制的，你可以参考下面这段 C 代码：

```c++
// 在堆中分配内存
char* p =  (char*)malloc(2048); // 在堆空间中分配 2048 字节的空间，并将分配后的引用地址保存到 p 中
 
// 使用 p 指向的内存
{
  // ....
}
 
// 使用结束后，销毁这段内存
free(p)；
p = NULL；
```

从上面这段 C 代码可以看出来，要使用堆中的一块空间，我们需要先调用 malloc 函数分配内存，然后再使用；当不再需要这块数据的时候，就要手动调用 free 函数来释放内存。如果这段数据已经不再需要了，但是又没有主动调用 free 函数来销毁，那么这种情况就称为内存泄漏。

另外一种使用的是自动垃圾回收的策略，如 JavaScript、Java、Python 等语言，产生的垃圾数据是由垃圾回收器来释放的，并不需要手动通过代码来释放。

对于 JavaScript 而言，也正是这个"自动"释放资源的特性带来了很多困惑，也让一些 JavaScript 开发者误以为可以不关心内存管理，这是一个很大的误解。

那么在本文，我们将围绕"JavaScript 的数据是如何回收的"这个话题来展开探讨。因为数据是存储在栈和堆两种内存空间中的，所以接下来我们就来分别介绍"栈中的垃圾数据"和"堆中的垃圾数据"是如何回收的。

## 调用栈中的数据是如何回收的

首先是调用栈中的数据，我们还是通过一段示例代码的执行流程来分析其回收机制，具体如下：

```js
function foo() {
  var a = 1
  var b = { name: '极客邦' }
  function showName() {
    var c = '极客时间'
    var d = { name: '极客时间' }
  }
  showName()
}
foo()
```

当执行到第 6 行代码时，其调用栈和堆空间状态图如下所示：

![执行到showName函数时的内存模型](./img/showName-memory-model.png)

从图中可以看出，原始类型的数据被分配到栈中，引用类型的数据会被分配到堆中。当 foo 函数执行结束之后，foo 函数的执行上下文会从堆中被销毁掉，那么它是怎么被销毁的呢？下面我们就来分析一下。

在上篇文章中，我们简单介绍过了，如果执行到 showName 函数时，那么 JavaScript 引擎会创建 showName 函数的执行上下文，并将 showName 函数的执行上下文压入到调用栈中，最终执行到 showName 函数时，其调用栈就如上图所示。与此同时，还有一个记录当前执行状态的指针（称为ESP），指向调用栈中 showName 函数的执行上下文，表现当前正在执行 showName 函数。

接着，当 showName 函数执行完成之后，函数执行流程就进入了 foo 函数，那这时就需要销毁 showName 函数的执行上下文了。ESP 这时候就帮上忙了，JavaScript 会将 ESP 下移到 foo 函数的执行上下文，这个下移操作就是销毁 showName 函数执行上下文的过程。

你可能会有点懵，ESP 指针向下移动怎么就能把 showName 的执行上下文销毁了呢？具体你可以看下面这张移动 ESP 前后的对比图：

![从栈中回收showName执行上下文](./img/recycle-showName-execute-context.png)

从图中可以看出，当 showName 函数执行结束之后，ESP 向下移动到 foo 函数的执行上下文中，上面 showName 的执行上下文虽然保存在栈内存中，但是已经是无效内存了。比如当 foo 函数再次调用另外一个函数时，这块内容会被直接覆盖掉，用来存放另外一个函数的执行上下文。

所以说，当一个函数执行结束之后，JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文。

## 堆中的数据是如何回收的

通过上面的讲解，我想现在你应该已经知道，当上面那段代码的 foo 函数执行结束之后，ESP 应该是指向全局执行上下文的，那这样的话，showName 函数和 foo 函数的执行上下文就处于无效状态了，不过保存在堆中的两个对象依然占用着空间，如下图所示：

![foo函数执行结束后的内存状态](./img/foo-memory-status.png)

从图中可以看出，1003 和 1050 这两块内存依然被占用。要回收堆中的垃圾数据，就需要用到 JavaScript 中的垃圾回收器了。

所以，接下来我们就来通过 Chrome 的 JavaScript 引擎 V8 来分析下堆中的垃圾数据是如何回收的。

## 代际假说和分代收集

不过在正式介绍 V8 是如何实现回收之前，你需要先学习下代际假说（The Generational Hypothesis）的内容，这是垃圾回收领域中一个重要的术语，后续垃圾回收的策略都是建立在该假说的基础之上的，所以很重要。

**代际假说有以下两个特点：**

- 第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问。

- 第二个是不死的对象，会活得更久。

其实这两个特点不仅仅适用于 JavaScript，同样适用于大多数的动态语言，如 Java、Python 等。

有了代际假说的基础，我们就可以来探讨 V8 是如何实现垃圾回收的了。

通常，垃圾回收算法有很多种，但是并没有哪一种能胜任所有的场景，你需要权衡各种场景，根据对象的生存周期的不同而使用不同的算法，以便达到最好的效果。

所以，在 V8 中会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。

新生区通常只支持 1~8M 的容量，而老生区支持的容量就大很多了。对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。

> **2025 补充**：在较新版本的 V8 中，新生代的半空间（semi-space）大小已经变为**可配置**的，并且根据设备内存和运行场景的不同，实际大小可能远超上述 1~8MB 的范围。V8 团队通过启发式策略动态调整新生代空间大小，以在内存占用和 GC 频率之间取得最优平衡。此外，V8 还引入了**分配折叠（Allocation Folding）**优化——当连续分配的多个小对象在逻辑上总是一起使用时，V8 会将它们的内存分配合并为一次操作，减少分配开销和 GC 压力。

- 副垃圾回收器（Minor GC / Scavenger），主要负责新生代的垃圾回收。

- 主垃圾回收器（Major GC / Mark-Compact），主要负责老生代的垃圾回收。

## 垃圾回收器的工作流程

现在你知道了 V8 把堆分成两个区域——新生代和老生代，并分别使用两个不同的垃圾回收器。其实不论什么类型的垃圾回收器，它们都有一套共同的执行流程。

第一步是标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。

第二步是回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。

第三步是做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续空间称为内存碎片。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎片，但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如接下来我们要介绍的副垃圾回收器。

那么接下来，我们就按照这个流程来分析新生代垃圾回收器（副垃圾回收器）和老生代垃圾回收器（主垃圾回收器）是如何处理垃圾回收的。

## 副垃圾回收器

副垃圾回收器主要负责新生区的垃圾回收。而通常情况下，大多数小的对象都会被分配到新生区，所以说这个区域虽然不大，但是垃圾回收还是比较频繁的。

新生代中用 Scavenge 算法来处理。所谓 Scavenge 算法，是把新生代空间对半划分为两个区域，一半是对象区域（From-Space），一半是空闲区域（To-Space），如下图所示：

![新生区要划分为对象区域和空闲区域](./img/cenozoic-divide.png)

新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。

在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。

完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种角色翻转的操作还能让新生代中的这两块区域无限重复使用下去。

由于新生代中采用的 Scavenge 算法，所以每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以为了执行效率，一般新生区的空间会被设置得比较小。

也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript 引擎采用了对象晋升策略，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。

> **2025 补充：并行清道夫（Parallel Scavenging）**
>
> 在 V8 的 Orinoco 项目中，新生代的 Scavenge 操作已经从最初的单线程执行升级为**并行清道夫**模式。具体来说：
>
> - **多线程复制**：在执行 Scavenge 时，V8 会启动多个辅助线程（Helper Threads）来并行地将存活对象从 From-Space 复制到 To-Space。主线程同样参与复制工作，但由于有多个线程分担，整体复制速度大幅提升。
> - **工作窃取（Work Stealing）**：各辅助线程之间采用工作窃取策略，当某个线程提前完成自己的任务后，会去帮助其他尚未完成的线程，从而实现负载均衡。
> - **停顿时间缩短**：对于典型的 Web 应用，并行 Scavenge 可以将新生代 GC 停顿从原来的几毫秒降低到 1 毫秒以下，这对于维持 60fps 的流畅动画至关重要。

## 主垃圾回收器

主垃圾回收器主要负责老生区中的垃圾回收。除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。因此老生区中的对象有两个特点，一个是对象占用空间大，另一个是对象存活时间长。

由于老生区的对象比较大，若要在老生区中使用 Scavenge 算法进行垃圾回收，复制这些大的对象将会花费比较多的时间，从而导致回收执行效率不高，同时还会浪费一半的空间。因而，主垃圾回收器是采用标记-清除（Mark-Sweep）的算法进行垃圾回收的。下面我们来看看该算法是如何工作的。

### 三色标记法（Tri-color Marking）

> **2025 补充**：早期的描述中，标记过程通常被简化为"标记/未标记"两种状态。但在 V8 的实际实现中，老生代使用的是更精确的**三色标记法**，它将堆中的对象分为三种颜色：
>
> - **白色（White）**：尚未被垃圾回收器访问到的对象。标记阶段结束后，仍为白色的对象即为垃圾，可以被安全回收。
> - **灰色（Gray）**：已经被垃圾回收器访问到，但其引用的子对象还没有全部被扫描完。灰色对象被放入一个标记工作表（Marking Worklist）中等待进一步处理。
> - **黑色（Black）**：已经被访问到，并且它引用的所有子对象都已经被扫描过了。黑色对象是确定的活动对象。
>
> 标记过程从根对象（全局对象、调用栈中的变量等）出发，将它们标记为灰色并放入工作表。然后不断从工作表中取出灰色对象，扫描其引用的子对象（将子对象标记为灰色），扫描完毕后将该对象标记为黑色。当工作表为空时，标记阶段结束，所有仍为白色的对象都是垃圾。
>
> 三色标记法的核心优势在于它天然支持**增量和并发标记**——可以随时暂停和恢复标记过程，因为灰色对象记录了"还有哪些工作没做完"。

首先是标记过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动元素，没有到达的元素就可以判断为垃圾数据。

比如最开始的那段代码，当 showName 函数执行退出之后，这段代码的调用栈和堆空间如下图所示：

![标记过程](./img/mark-process.png)

从上图你可以大致看到垃圾数据的标记过程，当 showName 函数执行结束之后，ESP 向下移动，指向了 foo 函数的执行上下文，这时候如果遍历调用栈，是不会找到引用 1003 地址的变量，也就意味着 1003 这块数据为垃圾数据，被标记为红色。由于 1050 这块数据被变量 b 引用了，所以这块数据会被标记为活动对象。这就是大致的标记过程。

接下来就是垃圾的清除过程。它和副垃圾回收器的垃圾清除过程完全不同，你可以理解这个过程是清除掉红色标记数据的过程，可参考下图大致理解下其清除过程：

![标记清除过程](./img/mark-sweep-process.png)

上面的标记过程和清除过程就是标记-清除算法，不过对一块内存多次执行标记-清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了另外一种算法——标记-整理（Mark-Compact），这个标记过程仍然与标记-清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。你可以参考下图：

![标记整理过程](./img/mark-compact-process.png)

### 写屏障（Write Barrier）

> **2025 补充**：在增量标记和并发标记的场景下，JavaScript 主线程在标记进行的同时还在不断执行代码、修改对象引用关系。这就可能导致一个问题：某个已经被标记为黑色（已扫描完成）的对象，在标记过程中又新增了对一个白色对象的引用。如果不做任何处理，这个白色对象就会在标记结束后被误判为垃圾而被回收，导致程序崩溃。
>
> 为了保证增量/并发标记的正确性，V8 使用了**写屏障（Write Barrier）**机制：
>
> - 每当 JavaScript 代码修改了某个对象的引用属性（例如 `obj.field = anotherObj`），V8 就会在赋值操作之后插入一段写屏障代码。
> - 写屏障会检查：如果被赋值的源对象（`obj`）是黑色的，而新引用的目标对象（`anotherObj`）是白色的，就将源对象重新标记为灰色，放回标记工作表中，确保后续重新扫描。
> - 这种机制遵循的是 **Dijkstra 风格的写屏障**（也称"插入屏障"），它保证了标记阶段的**三色不变量**——黑色对象不会直接指向白色对象。
>
> 写屏障虽然对每次引用赋值增加了微小的性能开销，但它是实现增量标记和并发标记正确性的基石，也是 V8 能够将 GC 停顿控制在极低水平的关键技术之一。

### 标记与分配速率的关系

> **2025 补充**：在 V8 的老生代 GC 中，**何时触发标记**是一个非常重要的决策。V8 使用了一种基于**分配速率（Allocation Rate）**的启发式策略来决定何时启动标记过程：
>
> - V8 会持续跟踪老生代的内存分配速率（即每单位时间内分配了多少内存）。
> - 当分配速率较高时，V8 会更早地启动标记过程，以避免堆内存增长过快而导致更大规模的 GC 停顿。
> - 反之，当分配速率较低时，V8 会推迟标记的启动，减少不必要的 GC 开销。
> - 这种策略确保了 GC 的工作量与应用程序的实际内存需求相匹配，而不是简单地在固定阈值触发。

## 全停顿

现在你知道了 V8 是使用副垃圾回收器和主垃圾回收器处理垃圾回收的，不过由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做全停顿（Stop-The-World）。

比如堆中的数据有 1.5GB，V8 实现一次完整的垃圾回收需要 1 秒以上的时间，这也是由于垃圾回收而引起 JavaScript 线程暂停执行的时间，若是这样的时间花销，那么应用的性能和响应能力都会直线下降。主垃圾回收器执行一次完整的垃圾回收流程如下图所示：

![全停顿](./img/stop-the-world.png)

在 V8 新生代的垃圾回收中，因其空间较小，且存活对象较少，所以全停顿的影响不大，但老生代就不一样了。如果在执行垃圾回收的过程中，占用主线程时间过久，就像上面图片展示的那样，花费了 200 毫秒，在这 200 毫秒内，主线程是不能做其他事情的。比如页面正在执行一个 JavaScript 动画，因为垃圾回收器在工作，就会导致这个动画在这 200 毫秒内无法执行的，这将会造成页面的卡顿现象。

为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为增量标记（Incremental Marking）算法。如下图所示：

![增量标记](./img/incremental-marking.png)

使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。

## V8 Orinoco 项目：现代垃圾回收的全面升级

> **2025 补充**：增量标记只是 V8 优化 GC 停顿的第一步。V8 团队在此基础上发起了代号为 **Orinoco** 的项目，目标是将垃圾回收的大部分工作从主线程转移出去，最大限度地减少 GC 对用户可感知性能的影响。Orinoco 引入了以下几项关键技术：

### 并发标记（Concurrent Marking）

传统的增量标记虽然将标记过程拆分为小步骤，但这些小步骤仍然在主线程上执行，占用的是主线程时间。**并发标记**则更进一步——它将标记工作完全转移到**辅助线程（Helper Threads）**上执行，而主线程可以继续运行 JavaScript 代码。

并发标记的工作流程：

1. **启动阶段**：主线程触发标记开始，将根对象标记为灰色并放入共享的标记工作表。
2. **并发阶段**：辅助线程从标记工作表中取出灰色对象，遍历其引用并标记子对象，这一过程与主线程的 JavaScript 执行**同时进行**。
3. **完成阶段（Finalization）**：当辅助线程完成大部分标记工作后，主线程会短暂暂停，执行一次快速的最终标记（处理在并发标记期间主线程新产生的引用变化），然后进入清除阶段。

由于大部分标记工作都在辅助线程完成，最终在主线程上产生的停顿非常短（通常在 1~2 毫秒以内），相比传统的全停顿方案有了质的提升。

### 并发清除（Concurrent Sweeping）

标记完成后，需要将标记为垃圾的对象所占用的内存释放回空闲列表（Free List）。这个清除过程在 Orinoco 中也被移到了**后台线程**上并发执行：

- 清除线程在后台扫描老生代的内存页（Pages），将标记为白色（垃圾）的对象回收，并更新空闲列表。
- 主线程在此期间继续正常执行 JavaScript，当需要分配新对象时，可以直接从已经清除完毕的空闲列表中获取内存。
- 如果主线程的分配速度超过了清除速度（即清除还没来得及释放足够的内存），主线程会暂时帮助清除工作，以保证分配不会失败。

### 增量整理（Incremental Compaction）

标记-整理（Mark-Compact）中的整理阶段需要移动存活对象，这是 GC 中最耗时的操作之一，因为涉及到大量的内存拷贝和指针更新。Orinoco 对此进行了优化：

- V8 不再对整个老生代进行全量整理，而是选择**碎片化最严重的少数几个内存页**进行整理。
- 这些页面上的存活对象会被增量地迁移到其他页面中，每次只迁移一小部分，避免长时间的停顿。
- 不需要整理的页面则只进行清除（Sweep），不涉及对象移动，开销极低。

### 懒清除（Lazy Sweeping）

懒清除是 V8 对清除阶段的另一项优化。标记完成后，V8 并不会立即清除所有标记为垃圾的对象，而是采用"按需清除"的策略：

- 只有当某个内存页上的空闲内存被请求时，V8 才会去清除该页上的垃圾对象。
- 这种延迟清除的方式可以将清除工作分散到后续的内存分配过程中，进一步减少一次性的 GC 停顿。

### Orinoco 的整体效果

通过上述优化，V8 的 GC 停顿时间在大多数场景下已经从早期的数百毫秒级别降低到了**毫秒甚至亚毫秒级别**。以一个典型的 Web 应用为例：

- 新生代 GC（Scavenge）：通过并行清道夫，单次停顿通常 < 1ms
- 老生代 GC（Major GC）：通过并发标记 + 并发清除 + 增量整理，主线程停顿通常 < 2ms
- 对于时间敏感的应用（如动画、游戏），这意味着 GC 几乎不会造成可感知的帧丢失

## 现代垃圾回收的性能监控

了解了 V8 垃圾回收的工作原理之后，作为开发者，我们还需要掌握如何在实际开发中监控和优化 GC 性能。以下是一些实用的工具和技巧。

### 使用 Chrome DevTools Performance 面板识别 GC 停顿

Chrome DevTools 的 Performance（性能）面板是诊断 GC 问题最直接的工具：

1. **录制性能轨迹**：打开 DevTools → Performance 面板 → 点击录制按钮，执行你怀疑有性能问题的操作，然后停止录制。
2. **查看 GC 事件**：在火焰图（Flame Chart）中，GC 事件通常显示为 `Minor GC`（新生代回收）和 `Major GC`（老生代回收）。它们出现在主线程的时间轴上，表示此时 JavaScript 执行被暂停。
3. **分析停顿时间**：点击具体的 GC 事件，可以查看其持续时间。如果发现频繁出现超过 10ms 的 GC 停顿，说明可能存在内存分配压力过大的问题。
4. **关注内存曲线**：Performance 面板顶部的内存曲线如果呈现**锯齿状（sawtooth pattern）**快速增长和回落，说明应用在频繁分配和回收大量临时对象。

### 使用 Memory 面板进行堆快照分析

DevTools 的 Memory（内存）面板提供了更深入的内存分析能力：

- **Heap Snapshot（堆快照）**：可以在特定时间点捕获整个堆的快照，查看当前存活的所有对象及其大小、引用关系。通过对比两个快照，可以找出内存泄漏——那些应该被回收但持续增长的对象。
- **Allocation Instrumentation on Timeline（分配时间线）**：可以记录一段时间内的对象分配情况，帮助你找到分配频率最高的代码路径。
- **Allocation Sampling（分配采样）**：以较低的性能开销对内存分配进行采样，适合在生产环境中使用。

### `performance.measureUserAgentSpecificMemory()` API

这是一个较新的浏览器 API，允许 JavaScript 代码在运行时测量页面的内存使用情况：

```js
// 注意：该 API 需要在跨域隔离（cross-origin isolated）的环境中使用
// 即需要设置 Cross-Origin-Opener-Policy 和 Cross-Origin-Embedder-Policy 响应头
async function measureMemory() {
  if (performance.measureUserAgentSpecificMemory) {
    const result = await performance.measureUserAgentSpecificMemory()
    console.log('总内存使用:', result.bytes, 'bytes')
    console.log('详细分解:', result.breakdown)
  }
}
```

与之前的 `performance.memory`（非标准、仅 Chrome 支持）不同，`measureUserAgentSpecificMemory()` 是一个标准化的 API，它：

- 返回的内存数据经过 GC 之后测量，结果更准确
- 支持按 iframe/Web Worker 维度分解内存使用
- 可以用于生产环境中的内存监控

### 减少 GC 压力的实用技巧

了解了 GC 的工作原理后，我们可以通过以下编程实践来减少 GC 压力，提升应用性能：

**1. 对象池化（Object Pooling）**

对于需要频繁创建和销毁的对象（如粒子特效、DOM 事件对象等），可以使用对象池模式来复用对象，避免反复触发 GC：

```js
class ObjectPool {
  constructor(createFn, resetFn, initialSize = 10) {
    this.createFn = createFn
    this.resetFn = resetFn
    this.pool = Array.from({ length: initialSize }, () => createFn())
  }

  acquire() {
    return this.pool.length > 0 ? this.pool.pop() : this.createFn()
  }

  release(obj) {
    this.resetFn(obj)
    this.pool.push(obj)
  }
}

// 使用示例：粒子对象池
const particlePool = new ObjectPool(
  () => ({ x: 0, y: 0, vx: 0, vy: 0, life: 0 }),
  (p) => { p.x = 0; p.y = 0; p.vx = 0; p.vy = 0; p.life = 0 }
)
```

**2. 避免隐藏类（Hidden Class）转换**

V8 内部为每个对象维护一个隐藏类（Hidden Class，也称 Map 或 Shape），用于优化属性访问。如果频繁以不同的顺序或动态地添加属性，会导致隐藏类频繁转换，增加内存碎片和 GC 压力：

```js
// ❌ 不推荐：动态添加属性，导致隐藏类转换
function createPoint(x, y) {
  const point = {}
  point.x = x  // 隐藏类转换 1
  point.y = y  // 隐藏类转换 2
  return point
}

// ✅ 推荐：在构造时一次性定义所有属性
function createPoint(x, y) {
  return { x, y } // 一次性创建，只有一个隐藏类
}

// ✅ 推荐：使用 class 保证所有实例共享相同的隐藏类
class Point {
  constructor(x, y) {
    this.x = x
    this.y = y
  }
}
```

**3. 预分配（Pre-allocation）**

如果你知道数组的最终大小，提前分配可以避免数组在增长过程中反复创建更大的底层存储并丢弃旧的存储（触发 GC）：

```js
// ❌ 不推荐：频繁 push 导致数组反复扩容
const arr = []
for (let i = 0; i < 10000; i++) {
  arr.push(i)
}

// ✅ 推荐：预分配大小
const arr = new Array(10000)
for (let i = 0; i < 10000; i++) {
  arr[i] = i
}
```

**4. 避免在热路径中创建临时对象**

在高频执行的代码路径（如动画循环、事件处理）中，尽量避免创建不必要的临时对象：

```js
// ❌ 不推荐：每次调用都创建新的临时对象
function animate() {
  const position = { x: calcX(), y: calcY() } // 每帧创建新对象
  render(position)
  requestAnimationFrame(animate)
}

// ✅ 推荐：复用已有对象
const position = { x: 0, y: 0 }
function animate() {
  position.x = calcX() // 修改已有对象
  position.y = calcY()
  render(position)
  requestAnimationFrame(animate)
}
```

## 主流 JavaScript 引擎的 GC 策略对比

不同的浏览器使用不同的 JavaScript 引擎，它们在垃圾回收策略上各有特色。下面我们来对比三大主流引擎——V8（Chrome/Edge/Node.js）、SpiderMonkey（Firefox）和 JavaScriptCore（Safari）的 GC 实现。

### V8（Chrome / Edge / Node.js）

| 特性 | 详情 |
| --- | --- |
| 分代策略 | 新生代（Scavenge）+ 老生代（Mark-Compact） |
| 新生代算法 | 并行 Scavenge（半空间复制） |
| 老生代标记 | 并发标记 + 增量标记（三色标记法） |
| 老生代清除 | 并发清除 + 懒清除 |
| 老生代整理 | 增量整理（仅整理碎片化严重的页面） |
| 写屏障 | Dijkstra 风格插入屏障 |
| 核心项目 | Orinoco |
| 优势 | 极低的主线程停顿；在大型 Web 应用和 Node.js 服务端场景下表现优异 |

### SpiderMonkey（Firefox）

| 特性 | 详情 |
| --- | --- |
| 分代策略 | Nursery（新生代）+ Tenured Heap（老生代） |
| 新生代算法 | 半空间复制（类似 Scavenge），Nursery 大小动态调整 |
| 老生代标记 | 增量标记 + 并发标记（zone-based，每个 zone 独立 GC） |
| 老生代清除 | 后台清除 |
| 老生代整理 | 压缩式 GC（Compacting GC），可选且增量化 |
| 写屏障 | 支持多种屏障（插入屏障和删除屏障结合） |
| 核心特性 | **Zone-based GC**——将堆按"区域"划分，不同区域（如不同 iframe、Web Worker）可以独立进行垃圾回收，互不影响 |
| 优势 | Zone 机制使得多标签页场景下 GC 互不干扰；对 Web 扩展（extension）的内存管理也更加精细 |

### JavaScriptCore（Safari / WebKit）

| 特性 | 详情 |
| --- | --- |
| 分代策略 | Eden（伊甸代）+ Old（老生代），结合更细粒度的年龄分级 |
| 新生代算法 | Eden 采集（Eden Collection），仅扫描最年轻的对象 |
| 老生代标记 | 并发 + 增量标记（使用 Riptide 算法，基于 Sapphire 理论改进） |
| 老生代清除 | 并发清除 |
| 老生代整理 | 使用 copying 和 sweeping 结合的方式处理碎片 |
| 写屏障 | **Generational Barrier + Concurrent Barrier**，双重屏障确保并发安全 |
| 核心项目 | Riptide（2017 年引入） |
| 优势 | Riptide 的设计目标是实现**几乎无停顿的 GC**，大部分标记和清除工作都在后台线程完成；对移动端 Safari 的低功耗设备尤其重要 |

### 三者对比小结

| 对比维度 | V8 | SpiderMonkey | JavaScriptCore |
| --- | --- | --- | --- |
| 新生代 | 并行 Scavenge | 半空间复制（Nursery） | Eden Collection |
| 老生代标记 | 并发 + 增量 | 增量 + 并发（zone-based） | 并发 + 增量（Riptide） |
| 最大停顿目标 | < 2ms（典型 Web 应用） | 数毫秒级别 | 接近零停顿 |
| 独特设计 | Orinoco 并行化 | Zone-based 隔离 | Riptide 几乎无停顿 |
| 适用场景侧重 | 通用 Web + 服务端 | 多标签页 + 扩展生态 | 移动端 + 低功耗设备 |

值得注意的是，三大引擎的 GC 策略都在持续演进中，彼此之间也在互相借鉴。例如，并发标记的思想在三个引擎中都得到了采用，只是在具体实现细节上有所不同。对于 Web 开发者而言，不需要过度关注某个引擎的具体实现，而应该遵循通用的内存管理最佳实践（如避免内存泄漏、减少不必要的临时对象创建等），这些实践在所有引擎中都能带来性能提升。

## 总结

好了，今天就讲到这里，下面我们就来总结下今天的主要内容。

首先我们介绍了不同语言的垃圾回收策略，然后说明了栈中的数据是如何回收的，最后重点讲解了 JavaScript 中的垃圾回收器是如何工作的。

从上面的分析你也能看出来，无论是垃圾回收的策略，还是处理全停顿的策略，往往都没有一个完美的解决方案，你需要花一些时间来做权衡，而这需要牺牲当前某几方面的指标来换取其他几个指标的提升。

在 2025 年的今天，V8 的 Orinoco 项目已经将这种权衡做到了极致——通过并发标记、并行清道夫、并发清除、增量整理和懒清除等一系列技术，将绝大部分 GC 工作从主线程转移到了后台线程，使得 GC 停顿几乎不再是 Web 应用性能的瓶颈。同时，SpiderMonkey 的 Zone-based GC 和 JavaScriptCore 的 Riptide 也各自以不同的设计哲学达到了类似的目标。

其实站在工程师的视角，我们经常需要在满足需求的前提下，权衡各个指标的得失，把系统设计得尽可能适应最核心的需求。

生活中处理事情的原则也与之类似，古人很早就说过"两害相权取其轻，两利相权取其重"，所以与其患得患失，不如冷静地分析哪些才是核心诉求，然后果断决策牺牲哪些以使得利益最大化。
