# 沙盒：页面和系统之间的隔离墙

> **2025 更新说明**：本文最初编写时，站点隔离（Site Isolation）还在逐步推广阶段。截至 2025 年，站点隔离已在 Chrome 的所有平台（桌面端和移动端）全面部署。Spectre 和 Meltdown 漏洞已从 2018 年的"新发现"变为有充分缓解措施的已知历史漏洞。此外，浏览器安全领域出现了许多新进展，包括 Origin-Keyed Agent Clusters、Privacy Sandbox 计划、WebAssembly 沙箱化、以及 Firefox 的 Project Fission 等。本文在保留原有核心内容的基础上补充了这些现代进展。

**从稳定视角来看，单进程架构的浏览器是不稳定的**，因为只要浏览器进程中的任意一个功能出现异常都有可能影响到整个浏览器，如页面卡死、浏览器崩溃等。不过浏览器的稳定性并不是本文讨论的重点，我们今天主要聊的是**浏览器架构是如何影响到操作系统安全的**。

浏览器本身的漏洞是单进程浏览器的一个主要问题，如果浏览器被曝出存在漏洞，那么在这些漏洞没有被及时修复的情况下，黑客就有可能通过恶意的页面向浏览器中注入恶意程序，其中最常见的攻击方式是利用**缓冲区溢出**，不过需要**注意这种类型的攻击和 XSS 注入的脚本是不一样的**。

- XSS 攻击只是将恶意的 JavaScript 脚本注入到页面中，虽然能窃取一些 Cookie 相关的数据，但是 XSS 无法对操作系统进行攻击。

- 而通过浏览器漏洞进行的攻击是可以入侵到浏览器进程内部的，可以读取和修改浏览器进程内部的任意内容，还可以穿透浏览器，在用户的操作系统上悄悄地安装恶意软件、监听用户键盘输入信息以及读取用户硬盘上的文件内容。

> 和 XSS 攻击页面想比，这类攻击无疑是枚"核弹"，它会将整个操作系统的内容暴露给黑客，这样我们操作系统上所有的资料都是不安全的了。

## 安全视角下的多进程架构

现代浏览器的设计目标是**安全、快速**和**稳定**，而这种核弹级杀伤性的安全问题就是一个很大的潜在威胁，因此在设计现代浏览器的体系架构时，需要解决这个问题。

![浏览器架构](./img/browser-framework.png)

观察上图，我们知道浏览器被划分为**浏览器内核**和**渲染内核**两个核心模块，其中浏览器内核是由网络进程、浏览器进程和 GPU 进程组成的，渲染内核就是渲染进程。那如果我们在浏览器中打开一个页面，这两个模块是怎么配合的呢？

所有的网络资源都是通过浏览器内核来下载的，下载后的资源会通过 IPC 将其提交给渲染进程（浏览器内核和渲染进程之间都是通过 IPC 来通信的）。然后渲染进程会对这些资源进行解析、绘制等操作，最终生成一幅图片。但是渲染进程并不负责将图片显示到界面上，而是将最终生成的图片提交给浏览器内核模块，由浏览器内核模块负责显示这张图片。

设计现代浏览器体系架构时，将浏览器划分为不同的进程是为了增加其稳定性。虽然设计成了多进程架构，不过这些模块之间的沟通方式有些复杂，也许你还有以下问题：

- 为什么一定要通过浏览器内核去请求资源，再将数据转发给渲染进程，而不直接从进程内部去请求网络资源？

- 为什么渲染进程只负责生成页面图片，生成图片还要经过 IPC 通知浏览器内核模块，然后让浏览器内核去负责展示图片？

通过以上方式不是增加了工程的复杂度吗？

要解释现代浏览器为什么要把这个流程弄得这么复杂，我们就得从系统安全的角度来分析。

## 安全沙箱

不过在解释这些问题之前，我们得先看看什么是安全沙箱。

上面我们分析过，由于渲染进程需要执行 DOM 解析、CSS 解析、网络图片解码等操作，如果渲染进程存在系统级别的漏洞，那么以上操作就有可能让恶意的站点获取到渲染进程的控制权限，进而又获取操作系统的控制权限，这对用户来说是非常危险的。

因为网络资源的内容存在着各种可能性，所以浏览器会默认所有的网络资源都是不可信的，都是不安全的。但谁也不能保证浏览器不存在漏洞，只要出现漏洞，黑客就可以通过网络内容对用户发起攻击。

我们知道，如果你下载了一个恶意程序，但是没有执行它，那么恶意程序是不会生效的。同理，浏览器之于网络内容也是如此，浏览器可以安全地下载各种网络资源，但是如果要执行这些网络资源，比如解析 HTML、解析 CSS、执行 JavaScript、图片编解码等操作，就需要非常谨慎了，因为一不小心，黑客就会利用这些操作对含有漏洞的浏览器发起攻击。

基于以上原因，我们需要在渲染进程和操作系统之间建一道墙，即便渲染进程由于存在漏洞被黑客攻击，但由于这道墙，黑客就获取不到渲染进程之外的任何操作权限。**将渲染进程和操作系统隔离的这道墙就是我们要聊的安全沙箱**。

浏览器中的安全沙箱是利用操作系统提供的安全技术，让渲染进程在执行过程中无法访问或者修改操作系统中的数据，在渲染进程需要访问系统资源的时候，需要通过浏览器内核来实现，然后将访问的结果通过 IPC 转发给渲染进程。

安全沙箱最小的保护单位是进程。因为进程浏览器需要频繁访问或者修改操作系统的数据，所以单进程浏览器是无法被安全沙箱保护的，而现代浏览器采用的多进程架构使得安全沙箱可以发挥作用。

## 安全沙箱如何影响各个模块功能

我们知道安全沙箱最小的保护单位是进程，并且能限制进程对操作系统资源的访问和修改，这就意味着如果要让安全沙箱应用在某个进程上，那么这个进程必须没有读写操作系统的功能，比如读写本地文件、发起网络请求、调用 GPU 接口等。

了解了被安全沙箱保护的进程会有一系列的受限操作之后，接下来我们就可以分析渲染进程和浏览器内核各自都有哪些职责，如下图：

![渲染进程和浏览器内核的职责](./img/render-browser-responsibility.png)

通过该图，我们可以看到由于渲染进程需要安全沙箱的保护，因此需要把在渲染进程内部涉及到和系统交互的功能都转移到浏览器内核中去实现。

**那安全沙箱是如何影响到各个模块功能的呢？**

### 1.持久存储

我们先来看看安全沙箱是如何影响到浏览器持久存储的。由于安全沙箱需要负责确保无法直接访问用户的文件系统，但是在渲染进程内部有访问 Cookie 的需求、有上传文件的需求，为了解决这些文件的访问需求，所以现代浏览器将读写文件的操作全部放在了浏览器内核中实现，然后通过 IPC 将操作结果转发给渲染进程。

具体来讲，如下文件内容的读写都是在浏览器内核中完成的：

- 存储 Cookie 数据的读写。通常浏览器内核会维护一个存放所有 Cookie 的 Cookie 数据库，然后当渲染进程通过 JavaScript 来读取 Cookie 时，渲染进程会通过 IPC 将读取 Cookie 的信息发送给浏览器内核，浏览器内核读取 Cookie 之后再将内容返回给渲染进程。

- 一些缓存文件的读写也是由浏览器内核实现的，比如网络文件缓存的读取。

### 2.网络访问

同样有了安全沙箱的保护，在渲染进程内部也是不能直接访问网络的，如果要访问网络，则需要通过浏览器内核。不过浏览器内核在处理 URL 请求之前，会检查渲染进程是否有权限请求该 URL，比如检查 XMLHttpRequest 或者 Fetch 是否是跨站点请求，或者检测 HTTPS 的站点中是否包含了 HTTP 的请求。

### 3.用户交互

渲染进程实现了安全沙箱，还影响到了一个非常重要的用户交互功能。

通常情况下，如果你要实现一个 UI 程序，操作系统会提供一个界面给你，该界面允许应用程序与用户交互，允许应用程序在该界面上进行绘制，比如 Windows 提供的是 HWND，Linux 提供的 X Window，我们就把 HWND 和 X Window 统称为窗口句柄。应用程序可以在窗口句柄上进行绘制和接收键盘鼠标信息。

不过在现代浏览器中，由于每个渲染进程都有安全沙箱的保护，所以在渲染进程内部是无法直接操作窗口句柄的，这也是为了限制渲染进程监控到用户的输入事件。

由于渲染进程不能直接访问**窗口句柄**，所以渲染进程需要完成以下两点大的改变。

- 第一点，渲染进程需要渲染出位图。为了向用户显示渲染进程渲染出来的位图，渲染进程需要将生成好的位图发送到浏览器内核，然后浏览器内核将位图复制到屏幕上。

- 第二点，操作系统没有将用户输入事件直接传递给渲染进程，而是将这些事件传递给浏览器内核。然后浏览器内核再根据当前浏览器界面的状态来判断如何调度这些事件，如果当前焦点位于浏览器地址栏中，则输入事件会在浏览器内核内部处理；如果当前焦点在页面的区域内，则浏览器内核会将输入事件转发给渲染进程。

之所以这样设计，就是为了限制渲染进程有监控用户输入事件的能力，所以所有的键盘鼠标事件都是由浏览器内核来接收的，然后浏览器内核再通过 IPC 将这些事件发送给渲染进程。

上面我们分析了由于渲染进程引入了安全沙箱，所以浏览器的持久存储、网络访问和用户交互等功能都不能在渲染进程内直接使用了，因此我们需要把这些功能迁移到浏览器内核中去实现，这让原本比较简单的流程变得复杂了。

## 站点隔离（Site Isolation）

所谓站点隔离是指 Chrome 将同一站点（包含了相同根域名和相同协议的地址）中相互关联的页面放到同一个渲染进程中执行。

最开始 Chrome 划分渲染进程是以标签页为单位的，也就是说整个标签页会被划分给某个渲染进程。但是，按照标签页划分渲染进程存在一些问题，原因就是一个标签页可能包含多个 iframe，而这些 iframe 又有可能来自于不同的站点，这就导致了多个不同站点中的内容通过 iframe 同时运行在同一个渲染进程中。

### Spectre 和 Meltdown 漏洞的历史背景

2018 年初，安全研究人员披露了两个由处理器架构导致的严重漏洞——**幽灵（Spectre）**和**熔毁（Meltdown）**。这两个漏洞利用了 CPU 的推测执行（Speculative Execution）机制，黑客可以通过精心构造的代码读取同一进程内的任意内存数据。如果攻击者入侵的进程没有安全沙箱的保护，还可以进一步发起对操作系统的攻击。

在披露之后的几年中，操作系统厂商、CPU 厂商和浏览器厂商已经部署了多层缓解措施：操作系统层面的内核页表隔离（KPTI）、CPU 微码更新、浏览器层面的站点隔离和 `SharedArrayBuffer` 限制等。虽然这些漏洞从根本上说是硬件层面的问题，很难完全消除，但综合缓解措施已经使得实际利用变得非常困难。

正是因为 Spectre 等漏洞的威胁，如果一个银行站点包含了一个恶意的 iframe，然后这个恶意的 iframe 利用侧信道漏洞去读取渲染进程内存中的数据，那么恶意程序就能读取银行站点渲染进程内的所有内容了，这对于用户来说就存在很大的风险了。

因此 Chrome 从 2017 年开始重构代码，将标签级的渲染进程重构为 iframe 级的渲染进程，然后严格按照同一站点的策略来分配渲染进程，这就是 Chrome 中的站点隔离。

实现了站点隔离，就可以将恶意的 iframe 隔离在恶意进程内部，使得它无法继续访问其他 iframe 进程的内容，因此也就无法攻击其他站点了。

### 站点隔离的全面部署（2025 更新）

站点隔离在 Chrome 中的部署经历了几个重要里程碑：

- **2018 年**：Chrome 67 在桌面端默认启用站点隔离。
- **2019 年**：Chrome 77 在 Android 端开始逐步启用站点隔离。
- **截至 2025 年**：站点隔离已在 Chrome 的所有平台（Windows、macOS、Linux、ChromeOS、Android）上**全面部署**，成为 Chrome 安全架构的基石。每个跨站 iframe 都运行在独立的渲染进程中，即使渲染进程被攻破，攻击者也只能访问同一站点的数据。

## 现代浏览器隔离的新进展（2025 更新）

### Origin-Keyed Agent Clusters

传统的站点隔离是基于"站点"（Site）的——即相同的协议和根域名（eTLD+1）。但在某些场景下，开发者需要更细粒度的隔离，即基于"源"（Origin）的隔离。

通过设置 HTTP 响应头 `Origin-Agent-Cluster: ?1`，网站可以选择启用**基于源的代理集群**。这意味着即使 `a.example.com` 和 `b.example.com` 属于同一站点，它们也会被分配到不同的 Agent Cluster 中，无法通过 `document.domain` 互相访问。这提供了更强的安全隔离，也有助于浏览器将它们分配到不同的进程中。

### Firefox 的 Project Fission

站点隔离并非 Chrome 独有。**Firefox 的 Project Fission** 是 Mozilla 实现站点隔离的工程项目，于 **Firefox 95（2021 年 12 月）**开始默认启用。Fission 将 Firefox 的渲染架构从"一个标签页一个进程"升级为"一个站点一个进程"，使得 Firefox 也具备了与 Chrome 类似的进程级站点隔离能力。

Fission 的实现对 Firefox 来说是一次重大的架构变革，涉及到渲染引擎、进程管理、IPC 通信等多个核心模块的重构。这也印证了站点隔离已成为现代浏览器的标配安全特性。

### WebAssembly 沙箱化

WebAssembly（Wasm）作为一种高性能的二进制指令格式，在现代 Web 应用中越来越普遍。浏览器对 WebAssembly 实施了多层沙箱化保护：

- **内存沙箱**：每个 WebAssembly 实例只能访问其自己的线性内存（Linear Memory），无法访问 JavaScript 堆或其他 Wasm 实例的内存。这是通过硬件级的内存边界检查（如利用虚拟内存的 guard pages）来实现的。

- **指令级限制**：WebAssembly 的指令集被设计为安全的——它不包含任何可以直接访问操作系统资源的指令（没有系统调用、没有文件 I/O、没有网络访问）。Wasm 只能通过导入的 JavaScript 函数来与外部世界交互。

- **进程隔离**：Wasm 代码运行在渲染进程的安全沙箱内，享受与 JavaScript 相同的进程级隔离保护。

- **Wasm 组件模型**：正在标准化中的 WebAssembly 组件模型（Component Model）将进一步细化 Wasm 模块之间的隔离边界，实现更精细的能力授权。

### Privacy Sandbox

**Privacy Sandbox** 是 Google 提出的一项重大计划，旨在在保护用户隐私的前提下，为广告生态系统提供替代第三方 Cookie 的解决方案。虽然 Privacy Sandbox 主要关注隐私，但其设计也与浏览器沙箱和隔离机制紧密相关：

- **Topics API**：替代第三方 Cookie 的兴趣广告方案。浏览器在本地根据用户的浏览历史计算出若干兴趣主题（Topics），广告平台只能获取有限的、粗粒度的兴趣信号，而非精确的浏览轨迹。所有计算都在浏览器沙箱内完成，用户数据不会离开设备。

- **Protected Audience API（前身为 FLEDGE）**：用于再营销和自定义受众广告。广告竞价在浏览器本地的隔离工作线程（Worklet）中进行，广告平台无法获取用户的具体浏览数据。Worklet 本身运行在严格的沙箱环境中，不能访问网络或其他页面数据。

- **Attribution Reporting API**：用于衡量广告转化效果。该 API 在浏览器内部记录广告展示和转化事件，仅向广告平台报告聚合后的统计数据，保护了用户级别的隐私。报告的生成和发送都在浏览器沙箱内完成，具有差分隐私等隐私保护机制。

Privacy Sandbox 的核心理念是将数据处理从远程服务器转移到浏览器本地沙箱中，利用浏览器的隔离能力来保护用户隐私，同时满足广告生态系统的合理需求。

## 总结

本文从操作系统安全的视角分析了浏览器的多进程架构。安全沙箱通过限制渲染进程的系统访问能力，在页面和操作系统之间建立了一道坚固的隔离墙。渲染进程的持久存储、网络访问和用户交互功能都必须通过浏览器内核间接完成，这虽然增加了架构复杂度，但极大地提升了安全性。

站点隔离将这种保护进一步推进到了 iframe 级别，确保不同站点的内容运行在独立的进程中。截至 2025 年，站点隔离已在 Chrome 和 Firefox 等主流浏览器中全面部署。Origin-Keyed Agent Clusters 提供了更细粒度的源级隔离选项。WebAssembly 的多层沙箱化确保了高性能计算不会危及安全。而 Privacy Sandbox 则展示了浏览器隔离技术在隐私保护领域的新应用方向。

浏览器的安全架构是一个持续演进的过程——从最初的单进程架构，到多进程沙箱隔离，再到站点隔离和跨源隔离，每一步都是对安全威胁的回应和对用户保护的加强。
